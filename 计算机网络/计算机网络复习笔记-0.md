# 计算机网络复习笔记

(主要是跟随复习书籍进度， 前面的有时间补上。)

(目标是在复习完成后， 对于提出的问题能够自行解答。)

## 传输层

1. IPV4， IP号是32个bit，端口号是16bit。
2. 在主机上每个套接字能够分配一个端口号，报文段通过套接字进入其所连接的进程。 套接字和端口号的关系？ 端口号是虚拟的一串数据么？
3.  socket的两个参数 一个是地址族选择ipv4， 一个是选择TCP、UDP, 其他的参数分别代表什么？
4. 利用目的IP和目的端口号定位一个UDP套接字， 利用源， 目的的IP和端口号4个定位一个TCP套接字， 除非是TCP报文段中携带了初始创建连接的请求。TCP需要4个字段对应， 因此相同端口号可能有多个TCP在使用通信进程， 而UDP只会有一个？
   - 是的。如web服务器使用80端口连接和通信。
5. 非持续的HTTP就需要每次重新建立TCP连接，建立一个新的套接字，并在随后关闭。
6. UDP只是做了运输协议能做的最少工作， 即多路复用和分解 + 少量的差错检测。
7. TCP需要在端系统维护连接状态， 包括接收和发送缓存，拥塞控制参数以及序号与确认号的参数。而UDP都不需要。
8. TCP首部开销20字节（加选项最多60字节）， UDP首部开销8字节。包含哪些？
9. 显然网络管理程序， 使用UDP更合适， 因为往往需要在网络高负载的情况下使用， 而TCP有通塞控制。
10. 计算检验和时， 除了UDP报文段以外还包括IP首部的一些字段？？？（为什么， 具体是什么？）
11. 长度字段是包括首部在内的UDP报文段长度。

![img](https://img-blog.csdnimg.cn/20190312180411236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDY3MzYwOA==,size_16,color_FFFFFF,t_70)

12. 使用的是16bit差错检测。（累加，回卷，反码）接收方直接累加， 全1否则检测数据很可能出现了差错。（验证的时候也需要累加和回卷， 之所以要回卷是因为最上位如果不回卷，那么只要有两位数据位都从0->1，就会通过差错检测， 而回卷后任意位置出现这种情况都不会。）

13. rdt 2.0 差错检测， 接收方反馈， 重传 。rdt2.0这样的被称为停等协议。

14. 接收方只需要检查序号即可确认确定到的分组是否一次重传。（一次重传？回退n步是一次后面的全部重传， 选择重传是每个都有单独的计时器。）

15. 冗余数据分组（duplicate data packet）是由于发送方发送数据，等待一个rtt+响应时延也没有收到回应后（这里使用的是一个倒计数定时器），重传导致的。这会使得接收方可能在没有丢失数据的情况下，收到多个相同序号的数据报。所以可以理解为拥塞控制是发送端，在第三次发送才被响应的情况下， 触发的， 不需要接收端再单独发送数据（还是说连续收到了三次来自接收端的确认？？？）

16. 流水线pipelining。 引入就需要增加：1）需要范围；2）发送和接收缓存多个分组；3）回退n步和选择重传。

17. GBN 回退N步也称为滑动窗口协议。使用累计确认ack, GBN接收方不需要缓存失序数据，因为也不会返回这一个的ack，只会返回之前有序末尾的ack，这样超时之后，发送方会整个重发。相应的，缺点就是，单个分组的差错就会导致GBN重传大量分组，许多分组根本没有必要重传。解决办法：选择重传。

18. TCP有一个32bit的序号字段，其中TCP序号是按照字节流进行计数的，而不是按分组计数。

19. 选择重传SR，每个分组必须有自己的逻辑定时器，因为超时后只会重发这一个分组。

20. 窗口的长度必须小于或等于需要空间大小的一半？？？

21. 通过假定一个分组在网络中的“存活时间不会超过某个最大的时间量来做到这一点，（高速网络 tcp 被假定为3min） 【RFC 1323】猜测这个时间可能也和ttl等有关。

22. MSS是应用层数据的最大长度，不包含TCP和IP首部，MSS一般根据MTU来设置(MSS <= MTU - 40字节（tcp、ip首部）)，确保能够放进一个链路层帧当中。

23. TCP报文段结构：

    ![这里写图片描述](https://img-blog.csdn.net/20180811081238887?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3plcWkxOTkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

24. TCP通常是将文件划分成长度为MSS的若干块，也有16bit的校验和。16bit的接收窗口字段，用于流量控制，指示接收方愿意接受的字节数量。TCP的首部长度是会变的，选项字段最多40字节，而头部长度是32bit的字的数量，最多是有60字节 -> 15个32bit的字，需要4位记录长度。

25. 标志字段URG: 存放了上层实体的紧急数据，紧急数据的最后一个字节由16bit的紧急数据指针字段指出，（有的话tcp需要通知上层？）

26. 标志字段RST SYN FIN用于连接建立和拆除

27. 标志字段PSH 被设置时，就只是接收方应该立即将数据交给上层。这里PSH和URG的适用场景有什么却别？这个指针的用处，如何使用？

28. 数据划分序号的时候，是没有考虑tcp，ip首部的，单纯计算数据的偏移位置（一般每次取一个MSS， 序号也是加一个MSS，直到最后一个）。

    ![image-20200610111938500](C:\Users\Magicbook\AppData\Roaming\Typora\typora-user-images\image-20200610111938500.png)

29. 确认号就该是接收到的序列号+1（目标字节）（累积确认）这一点和选择重传时应该是有差异的，如何区分归纳？

    - 在GBN中确认值(ACK) 是累计的,它定义了下一个希望接收的分组序号,同时也证实了此前所有的分组都已经被完好的接收了.在SR中,确认号(ACK)之定义完好接收的那一个分组的序号,并不反馈任何其他分组的信息.

30. RFC没有明确规定是回退N步 or 选择重传，一般是用的选择重传。

31. 初始需要设为随机值是为了避免之前已终止的连接两边使用了相同的ip端口，可能产生干扰。

32. 定时器的过期间隔： TimeoutInterval = EstimatedRTT + 4 * DevRTT

33. tcp每次重传时都会将下一次的超时时间间隔设为先前值的两倍（多次超时，指数增长）， 而不是用从EstimatedRTT和DevRTT推算出的值。（这可以避免之前发送的后面的消息也跟着都超时重传。）而受到上层应用数据or受到ACK都会重新使用计算结果 （tcp在超时时，逐渐忍受更长的超时间隔，起到了一定限度的拥塞控制效果。）以太坊也采用了类似的思路， 具体是？？？

34. 3次受到相同ack， tcp就执行快速重传。即在该报文段之前重传丢失的报文段。

35. TCP实际的差错恢复机制可以被分类为GBN协议和SR协议的结合体。

36. 什么是选择确认？？？是否需要进一步理解实际当前tcp协议的机制？

37. 流量控制：当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段，这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非0的rwnd值。

38. tcp建立连接在第三次就可以发送和接收有效载荷了。

39. 4次挥手我的理解是，最后服务端请求关闭发送FIN后，客户端回应ACK并定时等待，如果服务端没有收到ACK超时，会导致重发FIN， 这时客户端收到并重发ACK，再次等待（TIME_WAIT 状态消耗的时间是与具体实现有关，一般是30s or 1min or 2min），知道没再收到，关闭。（是否准确？？？）

40. 一种解决tcp dos攻击的方法？cookie因为ack一般攻击者收不到，但是来是可以轻易伪造的，要收到ack就需要在关键出口监听，或者路由攻击，相对较难。（dos攻击的就是原始的模式，半开连接会占用服务器缓存和变量）

41. 接收报文匹配的是套接字，不是单纯的端口。

42. 如果主机端口80不接受连接，主机将向源发送一个特殊的重置报文段，RST标志位为1. 如果是udp套接字不匹配，就会发送一个特殊的icmp数据报（具体？？？）（使用nmap扫描端口，防火墙阻挡可能就是什么也收不到。）

43. 从ABR的角度分析，可用比特率主要的冗余来源是哪几种？具体是什么？3种，一是由于缓存溢出等导致的数据丢失，导致的超时重传；二是提前重传还在队列中没有被丢弃的报文段；三是由于经历多段路由，后面路由丢失导致的之前几段路由失去作用，导致的冗余。

44. 两个窗口，rwnd是接收窗口，cwnd是拥塞窗口。发送未被响应的长度限制是他们之间的最小值（一段偏移: lastbytesend - lastbyteacked <= min{cwnd, rwnd}）。

45. 3个冗余ack指的是一个初始ack加上3个冗余ack，是4个ack，三个冗余ack是可能在超时之前出现的，只要中间一段报文段丢失，而后面的报文段正常及时发送，且没有超过丢失报文段的计时器。

46. tcp拥塞控制的算法主要包括：慢启动，拥塞避免和快速恢复（reno有的）。vegas加了观测rtt的变化判断拥塞，linux现在用的是cubic。

47. 什么是TCP分岔： tcp分岔具体是指，对于一个实际的查询流程，可能需要一个连接RTT+3个数据传输RTT才能响应，如果客户端到数据中心较远，网络通信RTT较高，体验较差。而通过1.在客户附近设置前端服务器，客户直接和前端服务器连接通信；2.前端服务器再和数据中心维护一个高带宽的tcp连接，这样，如果前端server和client很近，连接通信rtt可以忽略，而只剩下一个前端和数据中心传输的rtt + 数据中心的处理时延，大大优化了体验。（有一点疑问没太理解，为什么数据通信就只需要一次RTT了，是在前端已经处理了，只剩下唯一的查询了么？？？）


# leetcode 第190期周赛
## 试题内容
1. 检查单词是否为句中其他单词的前缀
    - 具体就是拆分, 判断开头字符是否匹配.可以利用startswith简洁代码.
    ```python
   "".startswith(...)
    ```
2. 定长子串中元音的最大数目
    - 我原先的思路是首先将元音和非元音进行一次快速转换，然后顺序截取计算数量（这样会超时，pop用时最久，切片略好但也会超时），最后是具体读取目标长度的开头和末尾，依次向后遍历得出结果。
    - 看了一下靠前的代码，具体思路上，不再急于对逻辑进行过度拆分。整理思路，直接一轮查询。
3. 二叉树中的伪回文路径
    - 我原先的思路是递归深度优先，进行遍历，在节点为空时返回提示True，在左右都被返回True时就检查是否满足，而伪回文就是检查奇数数的个数是否小于等于1.
    - 靠前的python代码思路类似，但是代码更加简洁。
    + 相比于我的代码他还充分利用了集合而非我的定长数组来缓存奇偶信息。
    ```python
   a = set()
   a.add(...)
   a.discard(...) # a.remove()对于集合中没有的会报异常，discard不会
    ```
    + 另外，单行返回也是简化的一点。
    ```python
    if not root: return 0
    ```  
    - 内部函数能够减少对外函数的同时，充分利用外层函数中的变量。
    ```python
    def f(self):
        a = 0
        def dfs(...):
            a += 1
            pass
        pass
    ```
4. 两个子序列的最大点积
    - 这个最开始没有想出来，实际是动态规划问题，实际应该有如下图的思考逻辑即可解决：
    ![image-0](https://github.com/LNZ001/Analysis-of-algorithm-exercises/blob/master/leetcode_weekly_competition/190/images/4题序列分析-动态规划.svg)
    - 这里的一个关键推进就是基于子序列的顺序性。